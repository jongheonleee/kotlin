package book.part4

// 프로그래밍 패러다임
    // 1. 절차지향 : 순서가 정해짐, 로직 중심
    // 2. 객체지향 : 객체 조합해서 프로그래밍
    // 3. 함수형 : 함수 선언이 핵심
        // 로직을 한수로 만들어서 함수들의 흐름에 따라 프로그래밍

// FP 주요 원칙
    // 1. 일급 객체 => 객체를 변수처럼 사용
    // 2. 순수 함수 => 외부 영향 안미치는 함수

// FP 의 데이터 특징
    // 1. 데이터 불변
    // 2. 새로운 데이터를 만들어서 반환

// FP 의 이점
    // 1. 간결함 -> 유지 보수성 좋음
    // 2. 멀티 쓰레드 환경 안전성

// 정리
    // FP에는 변수가 없음, FP에서는 불변 데이터만 이용하고 함수의 흐름에 따라 프로그래밍
    // FP는 불변과 순수 함수를 이용하여 부수 효과 x -> 스레드 안정성 확보 & 병렬 처리에 도움

// 프로그램에서 일급 객체?
    // OOP : 클래스, FP : 함수
    // 함수의 선언 위치와 구성요소, 그리고 함수가 변수처럼 이용 가능한지가 중요
    // 변수처럼 다른 함수의 호출 인수로 함수를 사용할 수 있는지, 함수를 반환값으로 사용할 수 있는지

// 순수함수?
    // 부수효과 x
    // 같은 매개변수 값으로 함수 호출하면 항상 같은 값을 반환


// 코틀린 함수 특징
    // 1. 독립적인 구성 단위 가능
    // 2. 다양한 구성 요소 포함 가능

// 코틀린에서 함수를 변수처럼 이용하는 방법 2가지
    // 1. 람다 함수
    // 2. 함수 참조 (:: 연산자)
fun main(args : Array<String>) {
    funVal1(10)
    val myFun = ::someFun
    myFun()
}
// 람다
val funVal1 = {x : Int ->
    println("hello world")
    x * 10
}

// 함수 참조
fun someFun() {
    println("im some Function!!")
}

